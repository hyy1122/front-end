## 阅读本文您将收获
* 堆栈和数据类型的概念
* 浅拷贝实现
* 深拷贝实现

## 写在前面
### 举个栗子

```
let a=[0,1,2,3,4],
b=a;
a[0]=1;
console.log(a,b); // a: [1,1,2,3,4],b: [1,1,2,3,4]
```
* WTF?明明b复制了a，为啥修改数组a，数组b也跟着变了

### 数据在内存中的存储
* 基本类型-存储在栈内存中
* 引用类型-地址在栈内存中，值存储在堆内存中

## 浅拷贝
* 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响

* 赋值表达式 `=`
* `Object.assign`
* 展开运算符(...)


## 深拷贝
* 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响

* 性能最快：`JSON.parse(JSON.stringify(obj))`
	* 具有循环引用的对象时，报错
	* 当值为函数或undefined时，无法拷贝

* 递归进行逐一赋值

```
deepClone(obj) {
    let result;
    if (typeof obj == 'object') {
        result = isArray(obj) ? [] : {}
        for (let i in obj) {
            result[i] = isObject(obj[i])||isArray(obj[i])?deepClone(obj[i]):obj[i]
        }
    } else {
        result = obj
    }
    return result
}
function isObject(obj) {
    return Object.prototype.toString.call(obj) == "[object Object]"
}
function isArray(obj) {
    return Object.prototype.toString.call(obj) == "[object Array]"
}
```
